/*
 * OLED.c
 *
 *  Created on: Mar 30, 2021
 *      Author: 黄又又
 */


#include "derivative.h" /* include peripheral declarations */
#include "OLED.h"
#include "BIT.h"
void OLED_Init(void) //系统初始化调用这个
{
  unsigned short i;
  
  //OLED对应的PORTC端口时钟打开并配置为GPIO
  OLED_CONF();

  //set as output
  DDR_OLED_DC;
  DDR_OLED_SCLK;
  DDR_OLED_MOSI;
  DDR_OLED_RESET; 
  
  OLED_DC_H;
  OLED_SCLK_H;
  OLED_MOSI_H;
  //产生硬件RESET信号
  OLED_RESET_L;
  for(i=0;i<3000;i++) {
	  OLED_Delay(100);
  }
  OLED_RESET_H;
    
  //根据手册的初始化序列
  OLED_SPI_Delay
  
 
  if (OLED_TYPE==SSD1306) {
		OLED_W_Ctl(0xae); //OLED off
		OLED_W_Ctl(0xd5); //Set Clock
		OLED_W_Ctl(0x80); 
		OLED_W_Ctl(0xa8); //行数
		OLED_W_Ctl(0x3f); 
		OLED_W_Ctl(0xd3); //行offset
		OLED_W_Ctl(0x00); 
		OLED_W_Ctl(0x40); //Start Line
		OLED_W_Ctl(0x8D); //电荷泵
		OLED_W_Ctl(0x14); 
		OLED_W_Ctl(0xa1); //设置方向 127对应Seg0
		OLED_W_Ctl(0xc8); //Com[n-1] -> Com0
		OLED_W_Ctl(0xda); //无Left/Right Remap，Alter Com Pin，A[5]=0 A[4]=1
		OLED_W_Ctl(0x12); 
		OLED_W_Ctl(0x81); //对比度
		OLED_W_Ctl(0xcf); 
		OLED_W_Ctl(0xd9); //PreCharge
		OLED_W_Ctl(0xf1); 
		OLED_W_Ctl(0xdb); //Vcom
		OLED_W_Ctl(0x40); 
		OLED_W_Ctl(0xa4); //显示
		OLED_W_Ctl(0xa6); //1对应像素on
		OLED_W_Ctl(0xaf); //OLED on
  }
  
  OLED_Clr();
  
}

void OLED_CONF(void)
{
    /* enable PORTC clock */
	SIM_SCGC5|=SIM_SCGC5_PORTB_MASK;	//PORTD0-3对应OLED控制，IO模拟SPI总线
	//SIM_SCGC5|=SIM_SCGC5_PORTE_MASK;	//PORTD0-3对应OLED控制，IO模拟SPI总线
	/*portC  set to GPIO*/	    
    PORTB_PCR3=PORT_PCR_MUX(0X1);
	PORTB_PCR1=PORT_PCR_MUX(0X1);
	PORTB_PCR2=PORT_PCR_MUX(0X1);
	PORTB_PCR0=PORT_PCR_MUX(0X1); 
}

//write a control word 'cw' to OLED 'cs'(CSA/CSB)
void OLED_W_Ctl(unsigned char cw) {
	unsigned char i;
	
	OLED_SPI_Delay
	
	//OLED_CS = 0;
	OLED_DC_L;//write ctl
	
	OLED_SPI_Delay
	
	i = 0x80; /* start sending MSB first */
	/* i是移位参数 */
	while(i) 
	{  
		if(cw & i)
		{
			/* sending a 1, set data high and put a rising edge on the clock */
			OLED_SCLK_L;
			OLED_MOSI_H;
			OLED_SPI_Delay     /* done here for duty cycle symmetry */
			OLED_SCLK_H;
			i>>=1;
		}
		else
		{
			/* sending a 0, set data low and put a rising edge on the clock */
			OLED_SCLK_L;
			OLED_MOSI_L;
			OLED_SPI_Delay     /* done here for duty cycle symmetry */
			OLED_SCLK_H;
			i>>=1;
		}
				
		OLED_SPI_Delay
	}	
	  
	OLED_DC_H;
	//OLED_CS = 1;
	
	OLED_SPI_Delay 
}

//write a data word 'dw' to OLED 'cs'(CSA/CSB)
void OLED_W_Dat(unsigned char dw) {
	unsigned char i;
	
	OLED_SPI_Delay
	
	//OLED_CS = 0;
	OLED_DC_H;//write data
	
	OLED_SPI_Delay
	
	i = 0x80; /* start sending MSB first */
	/* i是移位参数 */
	while(i) 
	{  
		if(dw & i)
		{
			/* sending a 1, set data high and put a rising edge on the clock */
			OLED_SCLK_L;
			OLED_MOSI_H;
			OLED_SPI_Delay     /* done here for duty cycle symmetry */
			OLED_SCLK_H;
			i>>=1;
		}
		else
		{
			/* sending a 0, set data low and put a rising edge on the clock */
			OLED_SCLK_L;
			OLED_MOSI_L;
			OLED_SPI_Delay     /* done here for duty cycle symmetry */
			OLED_SCLK_H; 
			i>>=1;
		}
		OLED_SPI_Delay
	}	
	
	OLED_DC_H;
	//OLED_CS = 1;
	
	OLED_SPI_Delay 
}


//clear OLED screen
void OLED_Clr(void) {
	unsigned char i,j;
	
	if (OLED_TYPE==SSD1325) {
		OLED_W_Ctl(0x75); /* set row address */
		OLED_W_Ctl(0x00); /* set row start address */
		OLED_W_Ctl(0x4f); /* set row end address */
		OLED_W_Ctl(0x15); /* set column address */
		OLED_W_Ctl(0x00); /* set column start address */
		OLED_W_Ctl(0x3f); /* set column end address */
		for(i=0;i<64;i++) {
			for(j=0;j<80;j++) {
				OLED_W_Dat(0x00);
			}
		}
	}

	if (OLED_TYPE==SSD1306) {
		for(i=0;i<8;i++) {
			OLED_W_Ctl(0xB0+i);	//选择行
			OLED_W_Ctl(0x00);	//选择列（0-127的Low）
			OLED_W_Ctl(0x10);	//选择列（0-127的High）
			for(j=0;j<128;j++) {
				OLED_W_Dat(0x00);
			}
		}
	}
}

void OLED_W_Test(void) {
	unsigned char i,j;

	
	if (OLED_TYPE==SSD1306) {
		for(i=0;i<4;i++) {
			OLED_W_Ctl(0xB0+i);	//选择行
			OLED_W_Ctl(0x00);	//选择列（0-127的Low）
			OLED_W_Ctl(0x10);	//选择列（0-127的High）
			for(j=0;j<58;j++) {
				OLED_W_Dat(0x98);
			}
		}
	}
	
}

//write a 8*8 character 'ch' to OLED at (lx,ly)
//don't set the 'ly' equal to 121-???
//don't set the 'lx' equal to 8-??
void OLED_W_Ch(unsigned char lx,unsigned char ly,char ch) {
	unsigned char i,j,nChar;
	unsigned short temp;
	
	if (OLED_TYPE==SSD1306) {
		OLED_W_Ctl(0xB0+(lx%8));
		nChar=(ly%128);  
		OLED_W_Ctl(0x00+(nChar&0x0f));//低四位
		OLED_W_Ctl(0x10+((nChar>>4)&0x0f));//高四位
		temp = (ch-0x20)*8;
		for(i=0;i<8;i++) {
			OLED_W_Dat(ASCII[temp+i]);
		}
	}
}

//write a string 'sch' to OLED  at (lx,ly)
void OLED_W_Str(unsigned char lx,unsigned char ly,char *sch) {
	char *p2ch = sch;
	unsigned char L_y = ly;
	while (*p2ch) {
		OLED_W_Ch(lx,L_y,*p2ch++);
		L_y += 8;
	}
}

//write a 128*64 bmp to OLED
void OLED_W_Bmp(char *bmp) {
	char *p2bmp = bmp;
	unsigned char i,j;
	j = 0;

	if (OLED_TYPE==SSD1306) {
		OLED_W_Ctl(0xB0);   //X
		OLED_W_Ctl(0x00);  //Y Low
		OLED_W_Ctl(0x10);  //Y High
		for(i=0;i<8;i++) {
			for(j=0;j<128;j++) {
				OLED_W_Dat(*p2bmp++);
			}
		}
	}
}



const unsigned char ASCII[] ={
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x03, 0x0F, 0x00, 0x03, 0x0F, 0x00, 0x00,
0x0C, 0x1E, 0x3F, 0x7E, 0x7E, 0x3F, 0x1E, 0x0C,
0x00, 0x00, 0x33, 0xC9, 0x49, 0x66, 0x00, 0x00,
0x00, 0x00, 0x48, 0xA8, 0x52, 0x15, 0x12, 0x00,
0x00, 0xA2, 0xC2, 0xB2, 0x9C, 0x60, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFC, 0x03, 0x00, 0x00,
0x00, 0x02, 0x1A, 0x07, 0x1A, 0x02, 0x00, 0x00,
0x10, 0x10, 0x10, 0xFE, 0x10, 0x10, 0x10, 0x00,
0x00, 0x00, 0x00, 0x40, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,
0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x01, 0x06, 0x18, 0x60, 0x80, 0x00,
0x00, 0x7E, 0x81, 0x81, 0x81, 0x81, 0x7E, 0x00,
0x00, 0x80, 0x80, 0xFF, 0x82, 0x82, 0x00, 0x00,
0x00, 0x00, 0xC6, 0x89, 0x91, 0xA1, 0xC2, 0x00,
0x00, 0x00, 0x76, 0x89, 0x89, 0x81, 0x42, 0x00,
0x00, 0x90, 0xFF, 0x91, 0x12, 0x1C, 0x10, 0x00,
0x00, 0x71, 0x89, 0x89, 0x89, 0x8F, 0x40, 0x00,
0x00, 0x71, 0x89, 0x89, 0x8A, 0x7C, 0x00, 0x00,
0x00, 0x07, 0x19, 0xE1, 0x01, 0x01, 0x03, 0x00,
0x00, 0x76, 0x89, 0x89, 0x89, 0x89, 0x76, 0x00,
0x00, 0x3E, 0x51, 0x91, 0x91, 0x91, 0x8E, 0x00,
0x00, 0x00, 0x00, 0xCC, 0xCC, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x4C, 0xCC, 0x80, 0x00, 0x00,
0x00, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x00,
0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00,
0x00, 0x10, 0x10, 0x28, 0x44, 0x44, 0x82, 0x00,
0x00, 0x0E, 0x11, 0xA1, 0x81, 0x02, 0x00, 0x00,
0x7E, 0xA1, 0xBD, 0xA5, 0x99, 0x81, 0x7E, 0x00,
0x80, 0xC0, 0xBC, 0x23, 0xBD, 0xC0, 0x80, 0x00,
0x00, 0x76, 0x89, 0x89, 0x89, 0xFF, 0x81, 0x00,
0x00, 0x43, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00,
0x00, 0x3C, 0x42, 0x81, 0x81, 0xFF, 0x81, 0x00,
0x00, 0xC3, 0x81, 0x9D, 0x89, 0xFF, 0x81, 0x00,
0x00, 0x03, 0x01, 0x1D, 0x89, 0xFF, 0x81, 0x00,
0x10, 0x73, 0x91, 0x81, 0x81, 0x42, 0x3C, 0x00,
0x81, 0xFF, 0x89, 0x08, 0x89, 0xFF, 0x81, 0x00,
0x00, 0x81, 0x81, 0xFF, 0x81, 0x81, 0x00, 0x00,
0x00, 0x01, 0x7F, 0x81, 0x81, 0x80, 0x70, 0x00,
0x81, 0xC3, 0x25, 0x18, 0x91, 0xFF, 0x81, 0x00,
0x00, 0xE0, 0x80, 0x80, 0x81, 0xFF, 0x81, 0x00,
0x81, 0xFF, 0x87, 0x18, 0x87, 0xFF, 0x81, 0x00,
0x01, 0xFF, 0xC1, 0x30, 0x0C, 0x83, 0xFF, 0x81,
0x3C, 0x42, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00,
0x00, 0x0E, 0x11, 0x11, 0x91, 0xFF, 0x81, 0x00,
0x3C, 0x42, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00,
0x80, 0x4E, 0x31, 0x11, 0x91, 0xFF, 0x81, 0x00,
0x00, 0x73, 0x8A, 0x89, 0x89, 0x49, 0xC6, 0x00,
0x03, 0x01, 0x81, 0xFF, 0x81, 0x01, 0x03, 0x00,
0x01, 0x7F, 0x81, 0x80, 0x81, 0x7F, 0x01, 0x00,
0x01, 0x07, 0x39, 0xC0, 0xC0, 0x39, 0x07, 0x01,
0x01, 0x7F, 0x81, 0x78, 0x81, 0x7F, 0x01, 0x00,
0x81, 0xC3, 0xA5, 0x18, 0xA5, 0xC3, 0x81, 0x00,
0x01, 0x03, 0x8D, 0xF0, 0x8D, 0x03, 0x01, 0x00,
0x00, 0xC3, 0x85, 0x99, 0xA1, 0xC3, 0x00, 0x00,
0x00, 0x00, 0x01, 0x01, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xC0, 0x38, 0x06, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 0x01, 0x00,
0x00, 0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00,
0x00, 0x68, 0x94, 0x94, 0x94, 0x54, 0xF8, 0x80,
0x00, 0x78, 0x84, 0x84, 0x84, 0x48, 0xFF, 0x81,
0x00, 0x4C, 0x88, 0x84, 0x84, 0x84, 0x78, 0x00,
0x80, 0xFF, 0x49, 0x84, 0x84, 0x84, 0x78, 0x00,
0x00, 0x98, 0x94, 0x94, 0x94, 0x94, 0x78, 0x00,
0x00, 0x85, 0x85, 0x85, 0xFE, 0x84, 0x84, 0x00,
0x01, 0x7F, 0x92, 0xA1, 0xA1, 0xA1, 0x1E, 0x00,
0x80, 0xF8, 0x84, 0x04, 0x88, 0xFF, 0x81, 0x00,
0x00, 0x80, 0x80, 0xFD, 0x84, 0x84, 0x00, 0x00,
0x00, 0x00, 0x7C, 0x85, 0x84, 0x84, 0x80, 0x00,
0x84, 0x84, 0xCC, 0x34, 0x10, 0xFF, 0x81, 0x00,
0x00, 0x80, 0x80, 0xFF, 0x81, 0x80, 0x00, 0x00,
0xF8, 0x04, 0x88, 0xF8, 0x04, 0x88, 0xFC, 0x84,
0x80, 0xF8, 0x84, 0x04, 0x88, 0xFC, 0x84, 0x00,
0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00,
0x00, 0x78, 0x84, 0x84, 0x88, 0xFC, 0x04, 0x00,
0x04, 0xFC, 0x48, 0x84, 0x84, 0x84, 0x78, 0x00,
0x00, 0x04, 0x84, 0x84, 0x88, 0xFC, 0x84, 0x00,
0x00, 0x6C, 0x94, 0x94, 0x94, 0x94, 0xC8, 0x00,
0x00, 0x40, 0x84, 0x84, 0x84, 0x7E, 0x04, 0x00,
0x80, 0xFC, 0x44, 0x80, 0x80, 0x7C, 0x04, 0x00,
0x04, 0x0C, 0x34, 0xC0, 0xC0, 0x34, 0x0C, 0x04,
0x04, 0x7C, 0x84, 0x70, 0x84, 0x7C, 0x04, 0x00,
0x00, 0x84, 0xCC, 0x30, 0x30, 0xCC, 0x84, 0x00,
0x01, 0x07, 0x19, 0xE0, 0x99, 0x87, 0x01, 0x00,
0x00, 0xC4, 0x8C, 0x94, 0xA4, 0xCC, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xEE, 0x10, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x10, 0xEE, 0x01, 0x00, 0x00,
0x00, 0x08, 0x10, 0x10, 0x08, 0x08, 0x10, 0x00,
0x00, 0x43, 0x81, 0x81, 0x81, 0x42, 0x3D, 0x01,
};

//time delay
void OLED_Delay(unsigned char dc) {
  unsigned char i;
  for(i=0;i<dc;i++) {
		asm("nop");
	}
}


/*将int型转化为字符串输出*/
void OLED_W_Numeral (unsigned char x,unsigned char y,int numeral) {
  int reversed = 0, length = 0;char _cflag;
  if (numeral < 0) { 
	  OLED_W_Str(x,y,"-"); numeral = -numeral; 
  }   //先对符号进行判断,如有符号,输出"-"
  while (numeral > 0) {
    reversed = reversed * 10 + (numeral % 10); 
    numeral /= 10; length++; }          //对数据的长度进行测量
  while (length > 0) {                  //根据测量的结果,逐一发出数据
	y += 8;
    _cflag='0'+reversed % 10;
    OLED_W_Ch(x,y,_cflag);
    reversed /= 10; length--;
  }  
}

unsigned char dtoa(unsigned char c1)
{
  return (c1>=10)? (c1+'A'-10):(c1+'0');
  
}
